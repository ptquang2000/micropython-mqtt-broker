# Identifier
PAYLOAD_FORMAT_INDICATOR = b'\x01'
MESSAGE_EXPIRY_INTERVAL = b'\x02'
CONTENT_TYPE = b'\x03'
RESPONSE_TOPIC = b'\x08'
CORRELATION_DATA = b'\x09'
SUBSCRIPTION_IDENTIFIER = b'\x0b'
SESSION_EXPIRY_INTERVAL = b'\x11' 
ASSIGNED_CLIENT_IDENTIFIER = b'\x12'
SERVER_KEEP_ALIVE = b'\x13'
AUTHENTICATION_METHOD = b'\x15'
AUTHENTICATION_DATA = b'\x16'
REQUEST_PROBLEM_INFORMATION = b'\x17'
WILL_DELAY_INTERVAL = b'\x18'
REQUEST_RESPONSE_INFORMATION = b'\x19'
RESPONSE_INFORMATION = b'\x1a'
SERVER_REFERENCE = b'\x1c'
REASON_STRING = b'\x1f'
RECEIVE_MAXIMUM = b'\x21'
TOPIC_ALIAS_MAXIMUM = b'\x22'
TOPIC_ALIAS = b'\x23'
MAXIMUM_QOS = b'\x24'
RETAIN_AVAILABLE = b'\x25'
USER_PROPERTY = b'\x26'
MAXIMUM_PACKET_SIZE = b'\x27'
WILDCARD_SUBCRIPTION_AVAILABLE = b'\x28'
SUBCRIPTION_IDENTIFIER_AVAILABLE = b'\x29'
SHARED_SUBCRIPTION_AVAILABLE = b'\x2a'

WILL_PROPERTIES = [
        WILL_DELAY_INTERVAL,
        PAYLOAD_FORMAT_INDICATOR,
        MESSAGE_EXPIRY_INTERVAL,
        CONTENT_TYPE,
        RESPONSE_TOPIC,
        CORRELATION_DATA,
        USER_PROPERTY
        ]

PROPERTY_DICT = {
        'will_properties': WILL_PROPERTIES
        }

PROPERTY_TRANS = {
        PAYLOAD_FORMAT_INDICATOR : 'payload_format_indicator',
        MESSAGE_EXPIRY_INTERVAL : 'message_expiry_interval',
        CONTENT_TYPE : 'content_type',
        RESPONSE_TOPIC : 'response_topic',
        CORRELATION_DATA : 'correlation_data',
        SUBSCRIPTION_IDENTIFIER : 'subcription_identifier',
        SESSION_EXPIRY_INTERVAL : 'session_expiry_interval',
        ASSIGNED_CLIENT_IDENTIFIER : 'assigned_client_identifier',
        SERVER_KEEP_ALIVE : 'server_keep_alive',
        AUTHENTICATION_METHOD : 'authentication_method',
        AUTHENTICATION_DATA : 'authentication_data',
        REQUEST_PROBLEM_INFORMATION : 'request_problem_information',
        WILL_DELAY_INTERVAL : 'will_delay_interval',
        REQUEST_RESPONSE_INFORMATION : 'request_response_information',
        RESPONSE_INFORMATION : 'response_information',
        SERVER_REFERENCE : 'server_reference',
        REASON_STRING : 'reasion_string',
        RECEIVE_MAXIMUM : 'receive_maximum',
        TOPIC_ALIAS : 'topic_alias',
        MAXIMUM_QOS : 'maximum_QoS',
        RETAIN_AVAILABLE : 'retain_availabel',
        USER_PROPERTY : 'user_property',
        MAXIMUM_PACKET_SIZE : 'maximum_packet_size',
        WILDCARD_SUBCRIPTION_AVAILABLE : 'wildcard_subcription_available',
        SUBCRIPTION_IDENTIFIER_AVAILABLE : 'subcription_identifier_available',
        SHARED_SUBCRIPTION_AVAILABLE : 'shared_subcription_available'
        }

PACKET_TYPE = {
    1: 'CONNECT',
    2: 'CONNACK',
    3: 'PUBLISH',
    12: 'PINGREQ',
    13: 'PINGRESP',
    14: 'DISCONNECT',
}

def utf8_encoded_string(payload):
  OFFSET = 2
  LSB = payload[0]
  MSB = payload[1]
  return payload[LSB+OFFSET:MSB+OFFSET], payload[MSB+OFFSET:] 

def variable_byte_integer(conn):
    multiplier = 1
    value = 0
    try:
        encoded_byte = conn.recv(1)[0]
        value += multiplier * (encoded_byte & 127)
        while 128 & encoded_byte != 0:
            encoded_byte = conn.recv(1)[0]
            value += multiplier * (encoded_byte & 127)
            if multiplier > 3 ** 128:
               return
            mutiplier *= 128
        return value, conn.recv(value)
    except AttributeError:
        try:
            buf = conn
            i = 1 
            while 128 & (encoded_byte:=buf[i]) != 0:
                i += 1
                if multiplier > 3 ** 128:
                    return
                value += multiplier * (encoded_byte & 127)
                mutiplier *= 128
            return value, buf[i:]
        except TypeError:
            X = int(conn / 128)
            encoded_byte = conn % 128 
            i = 1
            while X > 0:
                if X > 0:
                    i += 1
                    encoded_byte = encoded_byte | 128
                encoded_byte = X % 128 
                X = int(X / 128)
            return encoded_byte.to_bytes(i, 'big')

class Identifier():

    # Type
    BYTE = {
            PAYLOAD_FORMAT_INDICATOR,
            REQUEST_PROBLEM_INFORMATION,
            REQUEST_RESPONSE_INFORMATION,
            MAXIMUM_QOS,
            RETAIN_AVAILABLE,
            WILDCARD_SUBCRIPTION_AVAILABLE,
            SUBCRIPTION_IDENTIFIER_AVAILABLE,
            SHARED_SUBCRIPTION_AVAILABLE
            }
    BINARY_DATA = {
            CORRELATION_DATA,
            AUTHENTICATION_DATA
            }
    TWO_BYTE_INTEGER = {
            SERVER_KEEP_ALIVE,
            RECEIVE_MAXIMUM,
            TOPIC_ALIAS_MAXIMUM,
            TOPIC_ALIAS
            }
    FOUR_BYTE_INTEGER = {
            MESSAGE_EXPIRY_INTERVAL,
            SESSION_EXPIRY_INTERVAL,
            WILL_DELAY_INTERVAL,
            MAXIMUM_PACKET_SIZE
            }
    UTF8_ENCODED_STRING = {
            CONTENT_TYPE,
            RESPONSE_TOPIC,
            REASON_STRING,
            SERVER_REFERENCE,
            RESPONSE_INFORMATION,
            AUTHENTICATION_METHOD,
            ASSIGNED_CLIENT_IDENTIFIER
            }
    UTF8_STRING_PAIR = {
            USER_PROPERTY
            }

    def __init__(self, buf, max_length):
        self.buf = buf
        self.properties = dict()
        self.max_length = max_length
        self.length = 0

    def process_property(self):
        identifier, self.buf = PROPERTYE_TRANS[buf[0]], buf[1:]

        if identifier in Identifier.UTF8_STRING_PAIR:
            name, self.buf = utf8_encoded_string(buf)
            self.length += 2 + len(name)
            value, self.buf = utf8_encoded_string(buf)
            self.length += 2 + len(value)
            try:
                self.properties[identifier].append((name,value))
            except KeyError:
                self.properties.update({identifier: [(name, value)]})

        if identifier in self.properties.keys():
            raise ValueError('Protocol Error')

        if identifier in Identifier.BYTE:
            value, self.buf = self.buf[0], self.buf[1:]
            self.properties.update({identifier: value}) 
            self.length += 2

        if identifier in Indetifier.TWO_BYTE_INTEGER:
            value, self.buf = int.from_bytes(self.buf[0:2], 'big'), self.buf[2:]
            self.properties.update({identifier: value}) 
            self.length += 3

        if identifier in Indetifier.FOUR_BYTE_INTEGER:
            value, self.buf = int.from_bytes(self.buf[0:4], 'big'), self.buf[4:]
            self.properties.update({identifier: value}) 
            self.length += 5

        if indentifier in Identifier.UTF8_ENCODED_STRING:
            value, self.buf = utf8_encoded_string(buf)
            self.properties.update({identifier: value}) 
            self.length += 1 + len(string)

        raise ValueError('Identifier {0} not available'.format(identifier))

    def __getattr__(self, name):
        name = str(name)
        if name == 'will_properties':
            while self.length < self.max_length:
                self.process_property()
        else:
            raise AttributeError('Attribute {0} not available'.format(name))
        return self.properties 


def connect_strategy(packet, buf):
    # Variable header
    name, buf = utf8_encoded_string(buf)
    packet.variable_header.update({'protocol_name': name})
    
    ver, buf = buf[0], buf[1:]
    packet.variable_header.update({'protocol_version': ver})

    flags, buf = '{0:08b}'.format(buf[0]), buf[1:]
    packet.variable_header.update({
        'username_flag': flags[0],
        'password_flag': flags[1],
        'will_retain': flags[2],
        'will_QoS': flags[3:5],
        'will_flag': flags[5],
        'clean_start': flags[6],
        'reserved': flags[7]
        })

    keep_alive, buf = buf[0:2], buf[2:]
    packet.variable_header.update({'keep_alive': int.from_bytes(keep_alive, 'big')})

    property_length, buf = variable_byte_integer(buf)
    packet.variable_header.update({'property_length': property_length})
    if property_length != 0:
        pass
    
    # Payload
    client_id, buf = utf8_encoded_string(buf)
    packet.payload.update({'client_id': client_id})

    if packet.will_flag == 1:
        property_length, buf = variable_byte_integer(buf)
        packet.payload.update({'property_length': property_length})

        properties = Identifier(buf=buf, max_length=property_length)
        packet.payload.update(properties.will_properties)

        will_topic, buf = utf8_encoded_string(buf)
        packet.payload.update({'will_topic': will_topic})

        will_payload, buf = utf8_encoded_string(buf)
        packet.payload.update({'will_payload': will_payload})

    if packet.username_flag == '1':
        username, buf = utf8_encoded_string(buf)
        packet.payload.update({'username': username})
    if packet.password_flag == '1':
        password, buf = utf8_encoded_string(buf)
        packet.payload.update({'password': password})

def connack_strategy(packet):
    conn_ack_flags = Packet.RESERVED
    reason_code = Packet.SUCCESS

    property_length = variable_byte_integer(0)
    if packet.clean_start == 0 and reason_code == Packet.SUCCESS:
        conn_ack_flags |= 1

    buf = conn_ack_flags.to_bytes(1, 'big')
    buf += reason_code
    buf += property_length
    return buf

def publish_strategy(packet, buf):
    topic, buf = utf8_encoded_string(buf)
    packet.variable_header.update({'topic': topic})

    if packet.QoS_level == 0:
        packet_id, buf = buf[0:2], buf[2:]

    property_length, buf = variable_byte_integer(buf)
    packet.variable_header.update({'property_length': property_length})
    if property_length != 0:
        pass
    packet.payload.update({'': buf})

def disconnect_strategy(packet, buf):
    if len(buf) < 1:
        rc = Packet.NORMAL_DISCONNECT
        packet.variable_header.update({'reason_code': rc})
    elif len(buf) < 2:
        rc = buf[1]
        packet.variable_header.update({'reason_code': rc})
    else:
        properties, buf = buf[1], buf[2:]
        i = 0
        try:
            if property[i] == Packet.SESSION_EXPIRY_INTERVAL:
                i += 1
                self._session_expiry_interval = property[i:i+4]
                i += 4
            if self._session_expiry_interval.from_bytes('big') == 0:
                pass
            if property[i] == Packet.REASON_STRING:
                i += 1
            if property[i] == Packet.REASON_STRING:
                pass
            if property[i] == Packet.USER_PROPERTY:
                i += 1
                remain = property[i:]
                while remain[0] != Packet.SERVER_REFERENCE:
                    name, remain = utf8_encoded_string(remain)
                    i += 2 + len(name)
                    value, remain = utf8_encoded_string(remain)
                    i += 2 + len(value)

            if property[i] == Packet.SERVER_REFERENCE:
                i += 1
            if property[i] == Packet.SERVER_REFERENCE:
                pass
        except IndexError:
            pass
    packet.payload.update({'': None})

class Packet():
    # Packet type
    RESERVED = 0
    CONNECT = 1
    CONNACK = 2 
    PUBLISH = 3
    DISCONNECT = 14

    # Reason Code
    SUCCESS = b'\x00'
    NORMAL_DISCONNECT = b'\x00' 
    UNSPECIFIED_ERROR = b'\x80'
    MALFORMED_PACKET = b'\x81'
    PROTOCOL_ERROR = b'\x82'
    IMPLEMENT_SPECIFIC_ERROR = b'\x83'
    UNSUPPORTED_PROTOCOL_VERSION = b'\x84'

    def __init__(self, buf):
        self.packet_type = buf[0] >> 4
        self.flags = buf[0] & 15
        self.remain_length = 0 
        self.variable_header = dict()
        self.payload = dict()

    def __str__(self):
        out = '\n-- [{0}]'.format(PACKET_TYPE[self.packet_type])
        out += '\n-- [Fixed Header]'
        out += '\npacket type: {0} flags: {1:04b}'.format(
               self.packet_type , self.flags)
        out += '\n-- [Variable Header]'
        for key, val in self.variable_header.items():
            out += '\n{0}: {1}'.format(key.replace('_', ' '), val)    
        out += '\n-- [Payload]'
        for key, val in self.payload.items():
            out += '\n{0}: {1}'.format(key.replace('_', ' '), val)    
        return out

    def __getattr__(self, attr):
        try:
            return self.variable_header[str(attr)]
        except KeyError:
            if self.packet_type == Packet.PUBLISH:
                flags = '{0:04b}'.format(self.flags)
                attr = str(attr)
                if attr == 'DUP_flag':
                    return flags[0]
                if attr == 'QoS_level':
                    return flags[1:3]
                if attr == 'retain':
                    return flags[3]
            else:
                raise AttributeError('Packet does not have "{0}" attribute'.format(attr))

    @property
    def strategy(self):
        if Packet.CONNECT == self.packet_type:
            return connect_strategy
        elif Packet.PUBLISH == self.packet_type:
            return publish_strategy
        elif Packet.DISCONNECT == self.packet_type:
            return disconnect_strategy
        else:
            raise AttributeError('Packet type strategy not available')

    @property
    def response_strategy(self):
        if Packet.CONNECT == self.packet_type:
            return connack_strategy(self), Packet.CONNACK, Packet.RESERVED
        else:
            raise ValueError('Response action not available')

    @property
    def response_packet(self):
        try:
            response, packet_type, flags = self.response_strategy
        except ValueError:
            return None
        byte1 = (packet_type << 4 | flags).to_bytes(1, 'big')
        remain_length = len(response)
        byte2 = variable_byte_integer(remain_length)
        return byte1 + byte2 + response

    def __lshift__(self, conn):
        self.remain_length, buf = variable_byte_integer(conn)
        self.strategy(self, buf)
        return self.response_packet

